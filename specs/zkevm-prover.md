# zkEVM Prover

<!-- All glossary references in this file. -->

[g-state]: glossary.md#state
[g-zk-fault-proof]: glossary.md#zk-fault-proof
[g-mpt]: glossary.md#merkle-patricia-trie

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**

- [Overview](#overview)
- [ZKEVM Proof](#zkevm-proof)
- [The ZK Verifier Contract](#the-zk-verifier-contract)
- [Prover as an RPC Server](#prover-as-an-rpc-server)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## Overview

A prover is responsible for generating proof using the [Halo2 proving scheme](https://zcash.github.io/halo2/)
for a target blocks. This proof provides claims regarding the legitimacy of block data and state transitions.
A prover plays a vital role in the challenge process, serving as a key component of the challenger.

A [ZK fault proof][g-zk-fault-proof] states that a [state][g-state] transition from `S` to `S'` is valid.
It sounds like there are no big differences from validity proof. That's true. But the point is this is used
to prove the state transition `S` to `S''` is wrong by showing a valid state transition `S` to `S'`.

## ZKEVM Proof

In the context of the EVM, which is regarded as a Turing machine, the generation of proof requires demonstrating the
execution of opcode operations in arbitrary order. This proof serves as an evidence of computation for the EVM.
Additionally, validating the block data's integrity involves proving sub-operations such as
[Merkle Patricia Trie][g-mpt] and ECDSA verification.
To support the proof generation process for a target block, [zkevm-circuits] offer circuits capable of proving the
required sub-operations. These circuits provide the means to prove the integrity and validity of the block data.
By combining these circuits, a prover completes the overall validity proof for the target block.

See [zkevm-specs] for details about the statements claimed by the zk-proof.

## The ZK Verifier Contract

The proof generated by a prover can be verified through the verifier contract that includes the following interface.
The verification in a challenge process is implemented using the `verify` function provided by the verifier contract.

```solidity
interface ZKVerifier {
    function verify(
        uint256[] calldata proof,
        uint256[] calldata target_circuit_final_pair
    ) public view returns (bool);
}
```

## Prover as an RPC Server

[kroma-prover](https://github.com/kroma-network/kroma-prover) is implemented as a gRPC server that generates a zkevm
proof for the requested height block. It can be utilized as a local component on the challenger's machine
or as a remote [gRPC] server (prover as a service).

- Step 1:  An user (e.g., challenger) requests a zkevm-proof for a block of specific height to kroma-prover with
  a desired block height value.
- Step 2: A kroma-prover obtains the trace of the corresponding block from kroma-geth RPC.
- Step 3: And then a kroma-prover generates zkevm-proof for the target block, and return it to the user.

Operating a grpc-kroma-prover, which is launched only when necessary, can alleviate the situation where
regular challengers need to allocate excessive system resources due to the proof generation process
that is occasionally executed (perhaps rarely executed).

The detailed gRPC specification can be available at [prover-grpc-proto].

[zkevm-circuits]: https://github.com/kroma-network/zkevm-circuits
[gRPC]: https://grpc.io/
[zkevm-specs]: https://github.com/kroma-network/zkevm-specs
[prover-grpc-proto]: https://github.com/kroma-network/prover-grpc-proto
