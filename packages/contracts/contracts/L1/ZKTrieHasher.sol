// SPDX-License-Identifier: MIT
pragma solidity 0.8.15;

import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";

import { Bytes32 } from "../libraries/Bytes32.sol";

/**
 * @title IPoseidon2
 */
interface IPoseidon2 {
    function poseidon(bytes32[2] memory inputs) external pure returns (bytes32);
}

/**
 * @custom:proxied
 * @title ZKTrieHasher
 * @notice The ZKTrieHasher is contract which can produce a hash according to ZKTrie.
 *         This owns an interface of Poseidon2 that is required to compute hash used by ZKTrie.
 */
contract ZKTrieHasher {
    /**
     * @notice Poseidon2 contract generated by circomlibjs.
     */
    IPoseidon2 public immutable POSEIDON2;

    /**
     * @param _poseidon2 The address of poseidon2 contract.
     */
    constructor(address _poseidon2) {
        POSEIDON2 = IPoseidon2(_poseidon2);
    }

    /**
     * @notice Computes a hash of values.
     *
     * @param _compressedFlags Compressed flags.
     * @param _values          Values.
     *
     * @return A hash of values.
     */
    function _valueHash(uint32 _compressedFlags, bytes32[] memory _values)
        internal
        view
        returns (bytes32)
    {
        require(_values.length >= 1, "ZKTrieHasher: too few values for _valueHash");
        bytes32[] memory ret = new bytes32[](_values.length);
        for (uint256 i = 0; i < _values.length; ) {
            if ((_compressedFlags & (1 << i)) != 0) {
                ret[i] = _hashElem(_values[i]);
            } else {
                ret[i] = _values[i];
            }
            unchecked {
                ++i;
            }
        }
        if (_values.length < 2) {
            return ret[0];
        }
        return _hashElems(ret);
    }

    /**
     * @notice Computes a hash of an element.
     *
     * @param _elem Bytes32 to be hashed.
     *
     * @return A hash of an element.
     */
    function _hashElem(bytes32 _elem) internal view returns (bytes32) {
        (bytes32 high, bytes32 low) = Bytes32.split(_elem);
        return POSEIDON2.poseidon([high, low]);
    }

    /**
     * @notice Computes a hash of elements.
     *
     * @param _elems Bytes32 array to be hashed.
     *
     * @return A hash of element.
     */
    function _hashElems(bytes32[] memory _elems) internal view returns (bytes32) {
        require(_elems.length >= 2, "ZKTrieHasher: too few values for _hashElems");
        bytes32 baseH = POSEIDON2.poseidon([_elems[0], _elems[1]]);
        if (_elems.length == 2) return baseH;
        else if (_elems.length == 3) {
            return POSEIDON2.poseidon([baseH, _elems[2]]);
        }
        bytes32[] memory newValues = new bytes32[]((_elems.length + 1) >> 1);
        newValues[0] = baseH;
        uint256 j;
        for (uint256 i = 1; i < newValues.length; ) {
            j = i << 1;
            if (j + 1 < _elems.length) {
                newValues[i] = POSEIDON2.poseidon([_elems[j], _elems[j + 1]]);
            } else {
                newValues[i] = _elems[j];
            }
            unchecked {
                ++i;
            }
        }
        return _hashElems(newValues);
    }
}
