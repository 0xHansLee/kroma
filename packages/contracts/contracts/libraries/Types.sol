// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

/**
 * @title Types
 * @notice Contains various types used throughout the Kroma contract system.
 */
library Types {
    /**
     * @notice CheckpointOutput represents a commitment to the state of L2 checkpoint. The timestamp
     *         is the L1 timestamp that the output root is posted. This timestamp is used to verify
     *         that the finalization period has passed since the output root was submitted.
     *
     * @custom:field submitter     Address of the output submitter.
     * @custom:field outputRoot    Hash of the L2 output.
     * @custom:field timestamp     Timestamp of the L1 block that the output root was submitted in.
     * @custom:field l2BlockNumber L2 block number that the output corresponds to.
     */
    struct CheckpointOutput {
        address submitter;
        bytes32 outputRoot;
        uint128 timestamp;
        uint128 l2BlockNumber;
    }

    /**
     * @notice Struct representing the elements that are hashed together to generate an output root
     *         which itself represents a snapshot of the L2 state.
     *
     * @custom:field version                  Version of the output root.
     * @custom:field stateRoot                Root of the state trie at the block of this output.
     * @custom:field messagePasserStorageRoot Root of the message passer storage trie.
     * @custom:field blockHash                Hash of the block this output was generated from.
     * @custom:field nextBlockHash            Hash of the next block.
     */
    struct OutputRootProof {
        bytes32 version;
        bytes32 stateRoot;
        bytes32 messagePasserStorageRoot;
        bytes32 blockHash;
        bytes32 nextBlockHash;
    }

    /**
     * @notice Struct representing the elements that are hashed together to generate a public input.
     *
     * @custom:field coinbase         Account address for paying transaction fees to.
     * @custom:field timestamp        The block time.
     * @custom:field number           The block number.
     * @custom:field difficulty       Difficulty.
     * @custom:field gasLimit         Maximum gas allowed.
     * @custom:field baseFee          The base fee per gas.
     * @custom:field chainId          The chain ID.
     * @custom:field transactionsRoot Root hash of the transactions.
     * @custom:field stateRoot        Root hash of the state trie.
     * @custom:field txHashes         Array of hash of the transaction.
     */
    struct PublicInput {
        address coinbase;
        uint64 timestamp;
        uint64 number;
        uint256 difficulty;
        uint256 gasLimit;
        uint256 baseFee;
        uint256 chainId;
        bytes32 transactionsRoot;
        bytes32 stateRoot;
        bytes32[] txHashes;
    }

    /**
     * @notice Struct representing the elements that are hashed together to generate a block hash.
     *         Some of fields that are contained in PublicInput are omitted.
     *
     * @custom:field parentHash      RLP encoded parent hash.
     * @custom:field uncleHash       RLP encoded uncle hash.
     * @custom:field receiptsRoot    RLP encoded receipts root.
     * @custom:field logsBloom       RLP encoded logs bloom.
     * @custom:field gasUsed         RLP encoded gas used.
     * @custom:field extraData       RLP encoded extra data.
     * @custom:field mixHash         RLP encoded mix hash.
     * @custom:field nonce           RLP encoded nonce.
     * @custom:field withdrawalsRoot RLP encoded withdrawals root.
     */
    struct BlockHeaderRLP {
        bytes parentHash;
        bytes uncleHash;
        bytes receiptsRoot;
        bytes logsBloom;
        bytes gasUsed;
        bytes extraData;
        bytes mixHash;
        bytes nonce;
        bytes withdrawalsRoot;
    }

    /**
     * @notice Struct representing a deposit transaction (L1 => L2 transaction) created by an end
     *         user (as opposed to a system deposit transaction generated by the system).
     *
     * @custom:field from        Address of the sender of the transaction.
     * @custom:field to          Address of the recipient of the transaction.
     * @custom:field isCreation  True if the transaction is a contract creation.
     * @custom:field value       Value to send to the recipient.
     * @custom:field mint        Amount of ETH to mint.
     * @custom:field gasLimit    Gas limit of the transaction.
     * @custom:field data        Data of the transaction.
     * @custom:field l1BlockHash Hash of the block the transaction was submitted in.
     * @custom:field logIndex    Index of the log in the block the transaction was submitted in.
     */
    struct UserDepositTransaction {
        address from;
        address to;
        bool isCreation;
        uint256 value;
        uint256 mint;
        uint64 gasLimit;
        bytes data;
        bytes32 l1BlockHash;
        uint64 logIndex;
    }

    /**
     * @notice Struct representing a withdrawal transaction.
     *
     * @custom:field nonce    Nonce of the withdrawal transaction
     * @custom:field sender   Address of the sender of the transaction.
     * @custom:field target   Address of the recipient of the transaction.
     * @custom:field value    Value to send to the recipient.
     * @custom:field gasLimit Gas limit of the transaction.
     * @custom:field data     Data of the transaction.
     */
    struct WithdrawalTransaction {
        uint256 nonce;
        address sender;
        address target;
        uint256 value;
        uint256 gasLimit;
        bytes data;
    }

    /**
     * @notice Struct representing a challenge.
     *
     * @custom:field turn       The current turn.
     * @custom:field asserter   Address of the asserter.
     * @custom:field challenger Address of the challenger.
     * @custom:field segments   Array of the segment.
     * @custom:field segStart   The L2 block number of the first segment.
     * @custom:field segSize    The number of L2 blocks.
     * @custom:field timeoutAt  Timeout timestamp of the next turn.
     * @custom:field outputRoot The L2 output root to be replaced.
     * @custom:field approved   Whether the challenge was approved.
     */
    struct Challenge {
        uint256 turn;
        address asserter;
        address challenger;
        bytes32[] segments;
        uint256 segStart;
        uint256 segSize;
        uint256 timeoutAt;
        bytes32 outputRoot;
        bool approved;
    }

    /**
     * @notice Struct representing a validator's bond.
     *
     * @custom:field amount    Amount of the lock.
     * @custom:field expiresAt The expiration timestamp of bond.
     */
    struct Bond {
        uint128 amount;
        uint128 expiresAt;
    }
}
